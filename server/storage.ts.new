import { questions, userPreferences, users, type User, type InsertUser, type Question, type InsertQuestion, type UserPreference, type InsertUserPreference } from "@shared/schema";

export interface IStorage {
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Question methods
  getAllQuestions(): Promise<Question[]>;
  getQuestionById(id: number): Promise<Question | undefined>;
  createQuestion(question: InsertQuestion): Promise<Question>;
  
  // User Preferences methods
  getUserPreferences(userId: number): Promise<UserPreference[]>;
  updateUserPreference(preference: InsertUserPreference): Promise<UserPreference>;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private questionsList: Map<number, Question>;
  private userPrefs: Map<number, UserPreference>;
  private userId: number;
  private questionId: number;
  private prefId: number;

  constructor() {
    this.users = new Map();
    this.questionsList = new Map();
    this.userPrefs = new Map();
    this.userId = 1;
    this.questionId = 1;
    this.prefId = 1;
    
    // Add initial questions
    this.seedQuestions();
  }

  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.userId++;
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
  
  async getAllQuestions(): Promise<Question[]> {
    return Array.from(this.questionsList.values());
  }
  
  async getQuestionById(id: number): Promise<Question | undefined> {
    return this.questionsList.get(id);
  }
  
  async createQuestion(question: InsertQuestion): Promise<Question> {
    const id = this.questionId++;
    const newQuestion: Question = { ...question, id };
    this.questionsList.set(id, newQuestion);
    return newQuestion;
  }
  
  async getUserPreferences(userId: number): Promise<UserPreference[]> {
    return Array.from(this.userPrefs.values()).filter(
      (pref) => pref.userId === userId
    );
  }
  
  async updateUserPreference(preference: InsertUserPreference): Promise<UserPreference> {
    // Check if preference already exists
    const existingPref = Array.from(this.userPrefs.values()).find(
      (pref) => pref.userId === preference.userId && pref.questionId === preference.questionId
    );
    
    if (existingPref) {
      const updatedPref: UserPreference = {
        ...existingPref,
        isFavorite: preference.isFavorite,
        isCompleted: preference.isCompleted
      };
      this.userPrefs.set(existingPref.id, updatedPref);
      return updatedPref;
    } else {
      // Create new preference
      const id = this.prefId++;
      const newPref: UserPreference = { 
        ...preference, 
        id 
      };
      this.userPrefs.set(id, newPref);
      return newPref;
    }
  }
  
  private seedQuestions() {
    const questionsData: InsertQuestion[] = [
      {
        question: "What is Ruby on Rails?",
        answer: "Ruby on Rails, or Rails, is an open-source web application framework written in Ruby. It follows the MVC (Model-View-Controller) architectural pattern and emphasizes Convention over Configuration (CoC) and Don't Repeat Yourself (DRY) principles. Rails is designed to make programming web applications easier by making assumptions about what every developer needs to get started.",
        category: "Fundamentals",
        difficulty: "beginner",
      },
      {
        question: "Explain the MVC architecture in Rails",
        answer: "MVC (Model-View-Controller) is an architectural pattern that separates an application into three main components:\n\n- **Model**: Handles data and business logic. In Rails, models interact with the database, handle validation, associations, and callbacks.\n\n- **View**: Represents the user interface. In Rails, views are typically ERB (Embedded Ruby) templates that display data to users.\n\n- **Controller**: Acts as an intermediary between the Model and View. Controllers receive requests, interact with models to gather data, and pass that data to views for rendering.",
        category: "Architecture",
        difficulty: "beginner",
      },
      {
        question: "What are Rails migrations?",
        answer: "Migrations are a feature of Rails that allows you to evolve your database schema over time. They're Ruby classes that create, modify, or drop database tables, columns, or indexes. Migrations make it easier for teams to collaborate by providing a consistent way to modify the database structure.\n\n```ruby\nclass CreateUsers < ActiveRecord::Migration[6.1]\n  def change\n    create_table :users do |t|\n      t.string :name\n      t.string :email\n      t.timestamps\n    end\n  end\nend\n```",
        category: "Database",
        difficulty: "beginner",
      },
      {
        question: "What is Active Record in Rails?",
        answer: "Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic. It facilitates the creation and use of objects whose data requires persistent storage to a database. Active Record implements the Object-Relational Mapping (ORM) pattern, which connects rich objects to database tables.\n\n```ruby\nclass User < ApplicationRecord\n  has_many :posts\n  validates :email, presence: true, uniqueness: true\n  \n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\n```",
        category: "ORM",
        difficulty: "beginner",
      },
      {
        question: "Explain the difference between 'has_many' and 'has_many :through' associations",
        answer: "Both are Active Record associations used to set up relationships between models:\n\n- **has_many**: Creates a one-to-many relationship directly. For example, an Author has many Books.\n\n```ruby\nclass Author < ApplicationRecord\n  has_many :books\nend\n```\n\n- **has_many :through**: Creates a many-to-many relationship using a join model. For example, a Doctor has many Patients through Appointments.\n\n```ruby\nclass Doctor < ApplicationRecord\n  has_many :appointments\n  has_many :patients, through: :appointments\nend\n```\n\nThe key difference is that 'has_many :through' allows you to establish a many-to-many connection with another model through a third model (join table), while 'has_many' establishes a direct one-to-many relationship.",
        category: "ORM",
        difficulty: "intermediate",
      },
      {
        question: "What is the difference between 'destroy' and 'delete' in Rails?",
        answer: "Both methods are used to remove records from the database, but they operate differently:\n\n- **delete**: Performs a direct SQL DELETE operation, removing the record from the database without loading it or running any callbacks. It's faster but bypasses validations and callbacks.\n\n```ruby\nUser.delete(1)  # Deletes the user with ID 1\nusers.delete_all  # Deletes all users in the collection\n```\n\n- **destroy**: Loads the record, runs callbacks (like `before_destroy` and `after_destroy`), checks dependencies, and then removes it from the database. It's slower but ensures data integrity.\n\n```ruby\nuser.destroy  # Destroys a user instance\nUser.destroy(1)  # Loads and destroys the user with ID 1\nusers.destroy_all  # Loads and destroys all users in the collection\n```",
        category: "ORM",
        difficulty: "intermediate",
      },
      {
        question: "What are strong parameters in Rails?",
        answer: "Strong parameters are a feature of Rails that prevent assigning request parameters to models unless they have been explicitly permitted. This helps protect against mass assignment vulnerabilities. They are typically used in controllers to whitelist which parameters are allowed for mass assignment.\n\n```ruby\nclass UsersController < ApplicationController\n  def create\n    @user = User.new(user_params)\n    if @user.save\n      redirect_to @user\n    else\n      render 'new'\n    end\n  end\n  \n  private\n  \n  def user_params\n    params.require(:user).permit(:name, :email, :password)\n  end\nend\n```",
        category: "Security",
        difficulty: "intermediate",
      },
      {
        question: "Explain what the Rails Asset Pipeline is",
        answer: "The Asset Pipeline is a framework in Rails that concatenates, minifies, and compresses JavaScript and CSS assets. It also adds asset fingerprinting for browser caching. The primary features include:\n\n1. **Concatenation**: Combines multiple files into one, reducing HTTP requests.\n2. **Minification**: Removes unnecessary whitespace and comments to reduce file size.\n3. **Compression**: Further reduces file size using gzip.\n4. **Fingerprinting**: Appends a hash of the file content to filenames, enabling browsers to cache assets effectively.\n5. **Preprocessing**: Allows use of languages like Sass for CSS and CoffeeScript for JavaScript.\n\nStarting with Rails 6, Webpacker is the default JavaScript compiler, working alongside the asset pipeline.",
        category: "Frontend",
        difficulty: "intermediate",
      },
      {
        question: "What is turbolinks in Rails?",
        answer: "Turbolinks is a JavaScript library that speeds up page renders by using AJAX to replace only the body of the page and update the browser's history, rather than doing a full page reload. It makes navigating a web application faster by avoiding the overhead of full page rendering.\n\nWhen a user clicks a link, Turbolinks:\n1. Intercepts the click event\n2. Makes an AJAX request for the new page\n3. Replaces the current page's body with the new one\n4. Updates the browser's history using the History API\n\nThis creates a SPA-like experience without the complexity of a full single-page application framework. In Rails 7, Turbolinks has been replaced by Turbo, part of the Hotwire suite.",
        category: "Frontend",
        difficulty: "intermediate",
      },
      {
        question: "What are N+1 queries and how can you avoid them in Rails?",
        answer: "An N+1 query problem occurs when your code executes N additional queries to fetch related objects for N results from an initial query. This typically happens when you retrieve a collection of objects and then loop through them accessing their associations, causing one additional query per object.\n\n```ruby\n# This causes N+1 queries\nposts = Post.all\nposts.each do |post|\n  puts post.author.name # Executes a separate query for each post's author\nend\n```\n\nYou can avoid N+1 queries using **eager loading** with `includes`, `preload`, or `eager_load`:\n\n```ruby\n# This executes just 2 queries (one for posts, one for authors)\nposts = Post.includes(:author).all\nposts.each do |post|\n  puts post.author.name # No additional queries\nend\n```\n\nRails also provides the `bullet` gem which helps identify N+1 query problems during development.",
        category: "Performance",
        difficulty: "advanced",
      },
      {
        question: "What are callbacks in Rails?",
        answer: "Callbacks are methods that get called at certain moments in an object's lifecycle. They allow you to trigger logic before or after state changes in a model. For example, you might use a callback to set a default value before saving a record, or to send an email after creating a user.\n\nCommon callbacks include:\n\n```ruby\nclass User < ApplicationRecord\n  # Called before a new record is saved\n  before_create :generate_token\n  \n  # Called after a record is created\n  after_create :send_welcome_email\n  \n  # Called before validations when a record is created or updated\n  before_validation :normalize_email\n  \n  private\n  \n  def generate_token\n    self.token = SecureRandom.hex(10)\n  end\n  \n  def send_welcome_email\n    UserMailer.welcome_email(self).deliver_later\n  end\n  \n  def normalize_email\n    self.email = email.downcase.strip if email.present?\n  end\nend\n```\n\nCallbacks should be used with caution as they can make code harder to understand and test.",
        category: "ORM",
        difficulty: "intermediate",
      },
      {
        question: "Explain the different types of caching in Rails",
        answer: "Rails provides several types of caching to improve application performance:\n\n1. **Page Caching**: Caches an entire page as a static HTML file. Fast but rarely used now because it doesn't work with actions that require authentication.\n\n2. **Action Caching**: Similar to page caching but runs before filters first, allowing authentication checks. Removed from Rails 4 but available as a gem.\n\n3. **Fragment Caching**: Caches just parts of a view. Useful for dynamic pages with static components.\n\n```ruby\n<% cache product do %>\n  <div class=\"product\">\n    <%= product.name %>\n  </div>\n<% end %>\n```\n\n4. **Russian Doll Caching**: Nested fragment caching where inner fragments are embedded within outer fragments.\n\n5. **Low-Level Caching**: Manual caching of specific data using `Rails.cache.fetch`.\n\n```ruby\nRails.cache.fetch(\"product/#{product.id}/price\", expires_in: 12.hours) do\n  product.calculate_price\nend\n```\n\n6. **SQL Caching**: Rails automatically caches SQL queries during a single request.\n\n7. **HTTP Caching**: Using HTTP headers like ETag and Last-Modified for browser and proxy caching.",
        category: "Performance",
        difficulty: "advanced",
      },
      {
        question: "What is Hotwire in Rails?",
        answer: "Hotwire is a modern approach to building web applications without much JavaScript. It was introduced in Rails 7 and consists of three main components:\n\n1. **Turbo**: The successor to Turbolinks, which accelerates links and form submissions. It includes:\n   - Turbo Drive: Speeds up page navigation\n   - Turbo Frames: Updates specific parts of a page\n   - Turbo Streams: Delivers page changes over WebSocket\n\n2. **Stimulus**: A modest JavaScript framework for adding behavior to HTML\n\n3. **Strada**: For building mobile hybrid applications (less commonly used)\n\nHotwire allows Rails developers to build modern, dynamic interfaces using mostly server-side code, reducing the need for complex JavaScript frameworks like React or Vue.js.",
        category: "Frontend",
        difficulty: "advanced",
      },
      {
        question: "What are service objects in Rails?",
        answer: "Service objects are a design pattern for organizing business logic that doesn't clearly belong in a model or controller. They help maintain the 'skinny controller, skinny model' principle by extracting complex operations into dedicated classes.\n\nCommon use cases include:\n- Complex user registration processes\n- Interacting with external APIs\n- Operations that affect multiple models\n- Background processing tasks\n\n```ruby\n# app/services/order_processor.rb\nclass OrderProcessor\n  def initialize(order, payment_details)\n    @order = order\n    @payment_details = payment_details\n  end\n  \n  def process\n    return false unless @order.valid?\n    \n    begin\n      charge_payment\n      update_inventory\n      send_confirmation\n      true\n    rescue => e\n      # Handle error\n      false\n    end\n  end\n  \n  private\n  \n  def charge_payment\n    # Payment gateway logic\n  end\n  \n  def update_inventory\n    # Update inventory counts\n  end\n  \n  def send_confirmation\n    OrderMailer.confirmation(@order).deliver_later\n  end\nend\n```\n\nUsage:\n```ruby\nclass OrdersController < ApplicationController\n  def create\n    @order = Order.new(order_params)\n    processor = OrderProcessor.new(@order, payment_params)\n    \n    if processor.process\n      redirect_to order_path(@order), notice: 'Order was successfully placed.'\n    else\n      render :new\n    end\n  end\nend\n```",
        category: "Architecture",
        difficulty: "advanced",
      },
      {
        question: "Explain CSRF protection in Rails",
        answer: "Cross-Site Request Forgery (CSRF) is an attack that forces users to execute unwanted actions on a web application where they're authenticated. Rails protects against CSRF attacks by including a token in every form and verifying this token on form submission.\n\nHow it works:\n\n1. Rails generates a unique CSRF token for each user session\n2. The token is included in forms via the `form_authenticity_token` helper:\n\n```erb\n<%= form_for @user do |f| %>\n  <!-- Rails automatically includes the authenticity token -->\n  <%= f.text_field :name %>\n  <%= f.submit %>\n<% end %>\n```\n\n3. For non-GET AJAX requests, Rails stores the token in a header:\n\n```javascript\n// Rails automatically adds this with jQuery UJS or importmap setup\nheaders: {\n  'X-CSRF-Token': document.querySelector('meta[name=\"csrf-token\"]').content\n}\n```\n\n4. The `protect_from_forgery` method in ApplicationController enables this protection:\n\n```ruby\nclass ApplicationController < ActionController::Base\n  protect_from_forgery with: :exception\nend\n```\n\nThis ensures that only requests with valid tokens are processed.",
        category: "Security",
        difficulty: "intermediate",
      },
      {
        question: "What are concerns in Rails and when should you use them?",
        answer: "Concerns are a way to make large models or controllers more maintainable by extracting common behavior into reusable modules. They implement the DRY (Don't Repeat Yourself) principle by allowing shared code to be easily mixed into multiple classes.\n\n```ruby\n# app/models/concerns/searchable.rb\nmodule Searchable\n  extend ActiveSupport::Concern\n  \n  included do\n    scope :search, ->(query) { where(\"name LIKE ?\", \"%#{query}%\") }\n  end\n  \n  def search_summary\n    \"#{self.class.name} ##{id}: #{name}\"\n  end\n  \n  module ClassMethods\n    def advanced_search(options = {})\n      # Advanced search implementation\n    end\n  end\nend\n\n# app/models/product.rb\nclass Product < ApplicationRecord\n  include Searchable\n  # Other product-specific code\nend\n\n# app/models/category.rb\nclass Category < ApplicationRecord\n  include Searchable\n  # Other category-specific code\nend\n```\n\nConcerns are useful when:\n- Multiple models share the same behavior (like search, filtering, state management)\n- A single model has grown too large and needs to be broken down\n- You want to keep your models focused on their core responsibilities\n\nHowever, concerns should be used judiciously; they're not a substitute for proper object-oriented design.",
        category: "Architecture",
        difficulty: "intermediate",
      },
      {
        question: "What is the difference between `includes`, `preload`, and `eager_load` in ActiveRecord?",
        answer: "These methods help avoid N+1 query problems by loading associated records efficiently, but they work differently:\n\n1. **preload**: Loads the association data in a separate query. This always uses two (or more) queries and doesn't allow conditions on the associations.\n\n```ruby\nusers = User.preload(:posts) # Executes 2 queries\n# Query 1: SELECT * FROM users\n# Query 2: SELECT * FROM posts WHERE user_id IN (1,2,3,...)\n```\n\n2. **eager_load**: Uses a LEFT OUTER JOIN to load the primary and association data in a single query. This is ideal for smaller datasets but can create large result sets with many associations.\n\n```ruby\nusers = User.eager_load(:posts) # Executes 1 query\n# Query: SELECT users.*, posts.* FROM users LEFT OUTER JOIN posts ON posts.user_id = users.id\n```\n\n3. **includes**: Intelligently chooses between preload and eager_load strategies. By default, it uses preload, but if you add conditions on the associations, it switches to eager_load.\n\n```ruby\n# Uses preload strategy (2 queries)\nusers = User.includes(:posts)\n\n# Switches to eager_load strategy (1 query) because of the reference to the association in where\nusers = User.includes(:posts).where(\"posts.created_at > ?\", 1.week.ago)\n```\n\nChoose based on your specific needs: use includes for most cases, preload when you want to enforce separate queries, and eager_load when you specifically need a single query with a join.",
        category: "ORM",
        difficulty: "advanced",
      },
      {
        question: "Explain Rails routing and the different route types",
        answer: "Rails routing connects incoming HTTP requests to controller actions. The routes are defined in `config/routes.rb`.\n\nBasic route types include:\n\n1. **Simple Route**: Maps a URL to a specific controller action.\n\n```ruby\nget '/about', to: 'pages#about'\n```\n\n2. **Resource Route**: Creates a set of RESTful routes for a resource.\n\n```ruby\nresources :articles\n# Creates 7 routes: index, show, new, create, edit, update, destroy\n```\n\n3. **Nested Routes**: Represents parent-child relationships between resources.\n\n```ruby\nresources :magazines do\n  resources :ads\nend\n```\n\n4. **Member Routes**: Add additional routes for individual resource instances.\n\n```ruby\nresources :photos do\n  member do\n    get 'preview'\n  end\nend\n# Adds /photos/:id/preview\n```\n\n5. **Collection Routes**: Add additional routes for the entire resource collection.\n\n```ruby\nresources :photos do\n  collection do\n    get 'search'\n  end\nend\n# Adds /photos/search\n```\n\n6. **Namespace Routes**: Group controllers under a namespace.\n\n```ruby\nnamespace :admin do\n  resources :articles\nend\n# Routes to Admin::ArticlesController\n```\n\n7. **Scope Routes**: Group routes without requiring namespaced controllers.\n\n```ruby\nscope '/admin' do\n  resources :articles\nend\n# Routes to ArticlesController, but paths start with /admin\n```\n\n8. **Custom Route Constraints**: Add conditions for route matching.\n\n```ruby\nconstraints(host: /^www\\.example\\.com$/) do\n  get 'dashboard', to: 'dashboard#show'\nend\n```",
        category: "Architecture",
        difficulty: "intermediate",
      },
      {
        question: "How does authentication work in Rails?",
        answer: "Authentication in Rails verifies the identity of users accessing your application. While Rails doesn't include authentication out of the box, there are several approaches:\n\n1. **Devise**: A complete authentication solution with generators for models, views, and controllers.\n\n```ruby\n# Gemfile\ngem 'devise'\n\n# Setup\n$ rails generate devise:install\n$ rails generate devise User\n$ rails db:migrate\n```\n\n2. **From Scratch**: Rails provides `has_secure_password` for simple password authentication.\n\n```ruby\n# User model with bcrypt gem installed\nclass User < ApplicationRecord\n  has_secure_password\n  validates :email, presence: true, uniqueness: true\nend\n\n# In a controller\ndef create\n  user = User.find_by(email: params[:email])\n  if user&.authenticate(params[:password])\n    session[:user_id] = user.id\n    redirect_to root_path, notice: \"Logged in!\"\n  else\n    flash.now[:alert] = \"Invalid email or password\"\n    render :new\n  end\nend\n```\n\n3. **OAuth**: Authentication via third-party providers like Google, Facebook, etc. using OmniAuth.\n\n```ruby\n# Gemfile\ngem 'omniauth'\ngem 'omniauth-google-oauth2'\n\n# config/initializers/omniauth.rb\nRails.application.config.middleware.use OmniAuth::Builder do\n  provider :google_oauth2, ENV['GOOGLE_CLIENT_ID'], ENV['GOOGLE_CLIENT_SECRET']\nend\n```\n\nCommon authentication features include:\n- User registration and login\n- Password reset\n- Account confirmation\n- Session management\n- Remember me functionality\n- Account locking after failed attempts",
        category: "Security",
        difficulty: "intermediate",
      },
      {
        question: "Explain the different types of associations in ActiveRecord",
        answer: "ActiveRecord supports six types of associations:\n\n1. **belongs_to**: Sets up a one-to-one connection with another model, with the foreign key on the declaring model.\n\n```ruby\nclass Comment < ApplicationRecord\n  belongs_to :article # article_id foreign key in comments table\nend\n```\n\n2. **has_one**: Also sets up a one-to-one connection, but the foreign key is on the other model.\n\n```ruby\nclass User < ApplicationRecord\n  has_one :profile # user_id foreign key in profiles table\nend\n```\n\n3. **has_many**: A one-to-many relationship where one instance of the model has zero or more instances of another model.\n\n```ruby\nclass Article < ApplicationRecord\n  has_many :comments # article_id foreign key in comments table\nend\n```\n\n4. **has_many :through**: A many-to-many relationship using a join model.\n\n```ruby\nclass Doctor < ApplicationRecord\n  has_many :appointments\n  has_many :patients, through: :appointments\nend\n```\n\n5. **has_one :through**: A one-to-one relationship using a join model.\n\n```ruby\nclass Supplier < ApplicationRecord\n  has_one :account\n  has_one :account_history, through: :account\nend\n```\n\n6. **has_and_belongs_to_many**: A direct many-to-many relationship without a join model, using a join table.\n\n```ruby\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n```\n\nCommon options for associations include:\n- `:dependent` - Controls what happens to associated objects when this object is destroyed\n- `:class_name` - Specifies the class of the association\n- `:foreign_key` - Overrides the default foreign key name\n- `:source` - Specifies the source association name for a has_one/has_many :through association\n- `:validate` - Controls whether associated objects should be validated when this object is saved",
        category: "ORM",
        difficulty: "intermediate",
      },
      {
        question: "Explain the Rails autoloading mechanism",
        answer: "Rails autoloading allows you to use classes and modules without explicitly requiring their files. This mechanism has evolved over time:\n\n1. **Classic Autoloading (Rails < 6.0)**: Used `const_missing` to load files on demand when constants were referenced but not defined. While convenient, it had thread-safety issues.\n\n2. **Zeitwerk (Rails >= 6.0)**: The new code loader that's thread-safe and uses a more predictable algorithm based on file paths rather than constant names.\n\nHow Zeitwerk autoloading works:\n\n- Files must be named to match the class/module they define (snake_case filename for CamelCase class)\n- Directories must correspond to modules (e.g., `app/models/admin/user.rb` defines `Admin::User`)\n- Rails automatically infers the mapping between constants and files based on its load paths\n\n```\napp/models/user.rb → User\napp/models/admin/user.rb → Admin::User\napp/models/admin.rb → Admin\n```\n\nZeitwerk preloads most of your application in development by default, so you don't have to worry about load order issues. In production, Rails uses eager loading, which loads all your code at boot time.\n\nYou can explicitly require files when the automatic convention doesn't work:\n\n```ruby\n# In an initializer\nRails.autoloaders.main.ignore(\"lib/algorithms/some_weird_file.rb\")\nrequire \"algorithms/some_weird_file\"\n```",
        category: "Architecture",
        difficulty: "advanced",
      },
      {
        question: "What is polymorphic association in Rails?",
        answer: "Polymorphic associations allow a model to belong to more than one type of model using a single association. This is useful when you have a model that can be associated with multiple models.\n\nFor example, if you have a Comment model that can belong to either a Post or a Video:\n\n```ruby\nclass Comment < ApplicationRecord\n  belongs_to :commentable, polymorphic: true\nend\n\nclass Post < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n\nclass Video < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n```\n\nIn the database, you need two columns in the comments table:\n- `commentable_id`: Stores the ID of the associated record\n- `commentable_type`: Stores the class name of the associated record\n\n```ruby\nclass CreateComments < ActiveRecord::Migration[6.1]\n  def change\n    create_table :comments do |t|\n      t.text :content\n      t.references :commentable, polymorphic: true\n      t.timestamps\n    end\n  end\nend\n```\n\nUsage:\n```ruby\npost = Post.find(1)\npost.comments.create(content: \"Great post!\")\n# Creates a comment with commentable_id = 1, commentable_type = \"Post\"\n\nvideo = Video.find(2)\nvideo.comments.create(content: \"Nice video!\")\n# Creates a comment with commentable_id = 2, commentable_type = \"Video\"\n\ncomment = Comment.find(1)\ncomment.commentable # Returns the associated Post or Video\n```",
        category: "ORM",
        difficulty: "intermediate",
      },
      {
        question: "How would you implement a multi-tenant Rails application?",
        answer: "Multi-tenancy is the practice of serving multiple clients (tenants) from a single application instance. There are several approaches:\n\n1. **Separate Database per Tenant**:\n   - Most secure, but can be resource-intensive\n   - Requires connection switching based on the current tenant\n\n```ruby\nclass ApplicationController < ActionController::Base\n  around_action :switch_tenant_db\n  \n  private\n  \n  def switch_tenant_db(&block)\n    tenant = identify_tenant\n    config = ActiveRecord::Base.configurations[Rails.env].merge('database' => \"tenant_#{tenant.id}\")\n    ActiveRecord::Base.establish_connection(config).connection\n    yield\n  ensure\n    ActiveRecord::Base.establish_connection(Rails.env.to_sym)\n  end\n  \n  def identify_tenant\n    Tenant.find_by!(subdomain: request.subdomain)\n  end\nend\n```\n\n2. **Separate Schema per Tenant** (PostgreSQL):\n   - Offers good isolation while using a single database\n   - Uses PostgreSQL schemas to separate tenant data\n\n```ruby\n# Using the apartment gem\nclass ApplicationController < ActionController::Base\n  before_action :set_tenant\n  \n  def set_tenant\n    tenant = identify_tenant\n    Apartment::Tenant.switch!(tenant.subdomain)\n  end\nend\n```\n\n3. **Row-Level Separation** (single database, single schema):\n   - Simplest approach; adds a tenant_id to every table\n   - Relies on application logic to enforce tenant isolation\n\n```ruby\nclass ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\n  \n  default_scope { where(tenant_id: Current.tenant_id) }\n  \n  after_initialize :set_tenant_id, if: :new_record?\n  \n  private\n  \n  def set_tenant_id\n    self.tenant_id = Current.tenant_id\n  end\nend\n\nclass ApplicationController < ActionController::Base\n  before_action :set_current_tenant\n  \n  private\n  \n  def set_current_tenant\n    Current.tenant_id = identify_tenant.id\n  end\nend\n```\n\nConsiderations for multi-tenancy:\n- Data isolation security\n- Backup and restore procedures\n- Performance and scaling\n- Tenant-specific customizations\n- Shared vs. tenant-specific code",
        category: "Architecture",
        difficulty: "advanced",
      },
      {
        question: "What is the Rails middleware stack and how can you modify it?",
        answer: "The middleware stack in Rails is a series of components that process requests before they reach your application's controller actions, and process responses before they're sent back to the client. Each middleware focuses on a specific concern like logging, session management, or CSRF protection.\n\nTo view your application's middleware stack:\n\n```bash\n$ rails middleware\n```\n\nYou can modify the middleware stack in `config/application.rb` or an environment-specific config file:\n\n1. **Add middleware**:\n\n```ruby\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    # Add at the end of the stack\n    config.middleware.use Rack::ETag\n    \n    # Add after a specific middleware\n    config.middleware.insert_after ActionDispatch::Flash, MyCustomMiddleware\n    \n    # Add before a specific middleware\n    config.middleware.insert_before Rack::Head, AnotherMiddleware\n  end\nend\n```\n\n2. **Remove middleware**:\n\n```ruby\nconfig.middleware.delete Rack::Sendfile\n```\n\n3. **Swap middleware**:\n\n```ruby\nconfig.middleware.swap ActionDispatch::Flash, MyCustomFlash\n```\n\n4. **Create custom middleware**:\n\n```ruby\n# lib/middleware/request_timer.rb\nclass RequestTimer\n  def initialize(app)\n    @app = app\n  end\n  \n  def call(env)\n    start_time = Time.now\n    status, headers, response = @app.call(env)\n    \n    # Calculate request duration\n    duration = Time.now - start_time\n    \n    # Add custom header\n    headers['X-Request-Duration'] = duration.to_s\n    \n    [status, headers, response]\n  end\nend\n\n# config/application.rb\nconfig.middleware.use RequestTimer\n```\n\nEach middleware receives an 'app' that represents the next middleware in the stack. It processes the request (the env hash), calls the next middleware, receives its response, and can modify the response before returning it.",
        category: "Architecture",
        difficulty: "advanced",
      },
      {
        question: "What is database sharding and how would you implement it in Rails?",
        answer: "Database sharding is a technique for horizontally partitioning data across multiple database instances to improve scalability and performance. Unlike vertical partitioning (splitting different tables across databases), sharding divides the same table across multiple databases based on a shard key.\n\nImplementation approaches in Rails:\n\n1. **Using ActiveRecord connection switching**:\n\n```ruby\nclass User < ApplicationRecord\n  def self.shard_for_user(user_id)\n    shard_id = user_id % 4 # Simple sharding by modulo\n    \"shard_#{shard_id}\"\n  end\n  \n  def self.find_by_id(user_id)\n    shard = shard_for_user(user_id)\n    connected_to(shard: shard) do\n      where(id: user_id).first\n    end\n  end\nend\n\n# config/database.yml\nproduction:\n  primary:\n    database: app_production\n  shard_0:\n    database: app_shard_0\n  shard_1:\n    database: app_shard_1\n  shard_2:\n    database: app_shard_2\n  shard_3:\n    database: app_shard_3\n```\n\n2. **Using the Octopus gem**:\n\n```ruby\n# Gemfile\ngem 'ar-octopus'\n\n# config/shards.yml\nproduction:\n  shards:\n    shard_0:\n      adapter: mysql2\n      database: app_shard_0\n    shard_1:\n      adapter: mysql2\n      database: app_shard_1\n\n# Usage\nclass User < ApplicationRecord\n  def self.find_by_id(user_id)\n    shard_id = user_id % 2\n    Octopus.using(\"shard_#{shard_id}\") do\n      where(id: user_id).first\n    end\n  end\nend\n```\n\nConsiderations for sharding:\n\n1. **Shard key selection**: Choose a key that distributes data evenly and minimizes cross-shard operations\n2. **Transactions across shards**: These are challenging and may require eventual consistency\n3. **Schema changes**: Need to be applied to all shards\n4. **Joins across shards**: Difficult to perform efficiently\n5. **Rebalancing**: Moving data between shards can be complex\n\nSharding should be considered only after other scaling options (read replicas, vertical scaling, caching) have been exhausted, as it significantly increases operational complexity.",
        category: "Database",
        difficulty: "advanced",
      },
      {
        question: "What are background jobs in Rails and how do you implement them?",
        answer: "Background jobs allow you to perform time-consuming tasks asynchronously, improving user experience by not blocking request-response cycles. Common use cases include sending emails, processing uploads, generating reports, or interacting with external APIs.\n\nPopular background job processors for Rails:\n\n1. **Active Job + Sidekiq**:\n\nActive Job is Rails' built-in framework for declaring and running background jobs with various backends. Sidekiq is a popular, efficient background job processor that uses Redis.\n\n```ruby\n# Gemfile\ngem 'sidekiq'\n\n# config/application.rb\nconfig.active_job.queue_adapter = :sidekiq\n\n# app/jobs/notification_job.rb\nclass NotificationJob < ApplicationJob\n  queue_as :default\n  \n  def perform(user_id, message)\n    user = User.find(user_id)\n    NotificationService.new(user).deliver(message)\n  end\nend\n\n# Usage\nNotificationJob.perform_later(user.id, \"Hello World\")\n# Or with a delay\nNotificationJob.set(wait: 1.hour).perform_later(user.id, \"Hello later\")\n```\n\n2. **Delayed Job**:\n\nUses your database to store jobs, suitable for smaller applications.\n\n```ruby\n# Gemfile\ngem 'delayed_job_active_record'\n\n# config/application.rb\nconfig.active_job.queue_adapter = :delayed_job\n```\n\n3. **Good Job**:\n\nA modern ActiveJob backend using PostgreSQL for job storage and advisory locks for concurrency control.\n\n```ruby\n# Gemfile\ngem 'good_job'\n\n# config/application.rb\nconfig.active_job.queue_adapter = :good_job\n```\n\nKey considerations for background jobs:\n\n1. **Idempotency**: Jobs should be safe to run multiple times in case of failures and retries\n2. **Job arguments**: Serialize only database IDs or simple values, not complex objects\n3. **Error handling**: Implement proper retries and error reporting\n4. **Monitoring**: Track job completion, failures, and queue sizes\n5. **Scheduling**: Use scheduled jobs for recurring tasks\n\n```ruby\n# Recurring job with Sidekiq-Cron\nclass DailyReportJob < ApplicationJob\n  def perform\n    Report.generate_daily_summary\n  end\nend\n\n# config/initializers/sidekiq.rb\nschedule_file = \"config/schedule.yml\"\nif File.exist?(schedule_file)\n  Sidekiq::Cron::Job.load_from_hash YAML.load_file(schedule_file)\nend\n\n# config/schedule.yml\ndaily_report:\n  cron: \"0 0 * * *\" # Midnight every day\n  class: \"DailyReportJob\"\n  queue: reports\n```",
        category: "Architecture",
        difficulty: "intermediate",
      },
      {
        question: "What is Rack in Rails and why is it important?",
        answer: "Rack is a modular interface between Ruby web servers and Ruby web frameworks (like Rails). It standardizes how web servers and applications communicate through a simple API, enabling interoperability between different servers and frameworks.\n\nRack's core concept is simple: an application is an object that responds to the `call` method, accepts a hash of request data (the environment), and returns an array with three elements: HTTP status code, headers hash, and response body.\n\n```ruby\n# A simple Rack application\nclass HelloWorld\n  def call(env)\n    [200, { \"Content-Type\" => \"text/plain\" }, [\"Hello, World!\"]]\n  end\nend\n\n# config.ru (Rack configuration file)\nrequire_relative 'hello_world'\nrun HelloWorld.new\n```\n\nImportance of Rack in Rails:\n\n1. **Middleware**: Rails uses a stack of Rack middleware components to process requests. Each middleware handles a specific concern like logging, sessions, or routing.\n\n```ruby\n# A simple Rack middleware\nclass RequestLogger\n  def initialize(app)\n    @app = app\n  end\n  \n  def call(env)\n    start_time = Time.now\n    status, headers, body = @app.call(env)\n    duration = Time.now - start_time\n    \n    puts \"[LOG] #{env['REQUEST_METHOD']} #{env['PATH_INFO']} - #{duration}s\"\n    \n    [status, headers, body]\n  end\nend\n\n# Using in Rails\n# config/application.rb\nconfig.middleware.use RequestLogger\n```\n\n2. **Server Independence**: Rack allows Rails to work with different web servers (Puma, Unicorn, Passenger) without changing the application code.\n\n3. **Testing**: Rack provides tools for testing web applications without making actual HTTP requests.\n\n```ruby\n# Test with Rack::Test\nrequire 'rack/test'\n\nclass ApiTest < Minitest::Test\n  include Rack::Test::Methods\n  \n  def app\n    Rails.application\n  end\n  \n  def test_get_users\n    get '/api/users'\n    assert_equal 200, last_response.status\n    assert_includes last_response.body, 'users'\n  end\nend\n```\n\n4. **Mounting Applications**: Rack allows mounting different applications within each other, enabling you to embed a Sinatra app inside Rails, or vice versa.\n\n```ruby\n# config/routes.rb\nRails.application.routes.draw do\n  mount SinatraApp, at: '/sinatra'\nend\n```\n\nUnderstanding Rack helps Rails developers create custom middleware, optimize request handling, and better understand how Rails processes web requests.",
        category: "Architecture",
        difficulty: "advanced",
      },
      {
        question: "What are Active Storage and Action Text in Rails?",
        answer: "**Active Storage** and **Action Text** are modern frameworks introduced in Rails 5.2 and 6.0 respectively, to handle file uploads and rich text content.\n\n**Active Storage** provides an easy way to upload and attach files to Active Record models, with built-in support for cloud storage services.\n\nKey features:\n1. Multiple service support (Amazon S3, Google Cloud Storage, Microsoft Azure, local disk)\n2. On-the-fly image transformations using variants\n3. Direct uploads from browser to cloud storage\n4. Background processing for derivatives\n\n```ruby\n# Setup\n$ rails active_storage:install\n$ rails db:migrate\n\n# Model configuration\nclass User < ApplicationRecord\n  has_one_attached :avatar\n  has_many_attached :photos\nend\n\n# Controller usage\ndef create\n  @user = User.create!(user_params)\n  redirect_to user_path(@user)\nend\n\nprivate\n\ndef user_params\n  params.require(:user).permit(:name, :email, :avatar, photos: [])\nend\n\n# View usage\n<%= form_with model: @user do |form| %>\n  <%= form.file_field :avatar %>\n  <%= form.file_field :photos, multiple: true %>\n  <%= form.submit %>\n<% end %>\n\n# Displaying attachments\n<%= image_tag @user.avatar %>\n\n# Creating variants (resized versions)\n<%= image_tag @user.avatar.variant(resize_to_limit: [100, 100]) %>\n```\n\n**Action Text** provides rich text editing capabilities, built on top of the Trix editor.\n\nKey features:\n1. WYSIWYG editing\n2. Embedded images and attachments\n3. Seamless integration with Active Record\n4. Content stored as HTML\n\n```ruby\n# Setup\n$ rails action_text:install\n$ rails db:migrate\n\n# Model configuration\nclass Article < ApplicationRecord\n  has_rich_text :content\nend\n\n# Controller usage\ndef article_params\n  params.require(:article).permit(:title, :content)\nend\n\n# View usage\n<%= form_with model: @article do |form| %>\n  <%= form.label :title %>\n  <%= form.text_field :title %>\n  \n  <%= form.label :content %>\n  <%= form.rich_text_area :content %>\n  \n  <%= form.submit %>\n<% end %>\n\n# Displaying rich text\n<%= @article.content %>\n```\n\nBehind the scenes, Action Text uses Active Storage for file attachments and Trix (a JavaScript editor) for the user interface. The rich text content is stored in a separate `action_text_rich_texts` table, with a polymorphic association to your model.",
        category: "Frontend",
        difficulty: "intermediate",
      },
      {
        question: "What are the differences between STI and Polymorphic Associations in Rails?",
        answer: "Single Table Inheritance (STI) and Polymorphic Associations are two different techniques in Rails for handling inheritance and relationships between models, each with its own use cases.\n\n**Single Table Inheritance (STI)**\n\nSTI stores all classes in an inheritance hierarchy in a single database table. The `type` column determines which class the record belongs to.\n\n```ruby\n# Migration\nclass CreateVehicles < ActiveRecord::Migration[6.1]\n  def change\n    create_table :vehicles do |t|\n      t.string :type # Stores the class name: 'Car', 'Truck', etc.\n      t.string :make\n      t.string :model\n      t.integer :wheels\n      t.boolean :convertible # Car-specific\n      t.integer :cargo_capacity # Truck-specific\n      t.timestamps\n    end\n  end\nend\n\n# Models\nclass Vehicle < ApplicationRecord\n  # Common vehicle methods\nend\n\nclass Car < Vehicle\n  # Car-specific methods\n  # Can only access convertible if it's a Car\nend\n\nclass Truck < Vehicle\n  # Truck-specific methods\n  # Can only access cargo_capacity if it's a Truck\nend\n```\n\n**Polymorphic Associations**\n\nPolymorphic associations allow a model to belong to multiple types of models using a single association. It requires `_id` and `_type` columns to track the associated model.\n\n```ruby\n# Migrations\nclass CreateComments < ActiveRecord::Migration[6.1]\n  def change\n    create_table :comments do |t|\n      t.text :content\n      t.references :commentable, polymorphic: true\n      t.timestamps\n    end\n  end\nend\n\nclass CreatePosts < ActiveRecord::Migration[6.1]\n  def change\n    create_table :posts do |t|\n      t.string :title\n      t.text :content\n      t.timestamps\n    end\n  end\nend\n\nclass CreatePhotos < ActiveRecord::Migration[6.1]\n  def change\n    create_table :photos do |t|\n      t.string :title\n      t.string :image_url\n      t.timestamps\n    end\n  end\nend\n\n# Models\nclass Comment < ApplicationRecord\n  belongs_to :commentable, polymorphic: true\nend\n\nclass Post < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n\nclass Photo < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n```\n\n**Key Differences**\n\n1. **Purpose**:\n   - STI: Models share the same attributes but have different behavior (inheritance)\n   - Polymorphic: Different models share a common relationship with another model\n\n2. **Table Structure**:\n   - STI: One table for all models in the hierarchy\n   - Polymorphic: Separate tables for each model type\n\n3. **When to Use**:\n   - STI: When subclasses share most attributes and behavior (e.g., User → Admin, Customer)\n   - Polymorphic: When unrelated models need the same type of association (e.g., Comments on Posts, Photos)\n\n4. **Drawbacks**:\n   - STI: Table bloat with unused columns for some subclasses\n   - Polymorphic: More complex queries and can't use foreign key constraints directly\n\nThere's also a third option worth mentioning: **Class Table Inheritance (CTI)**, which uses separate tables for each subclass and joins them when needed. This avoids the table bloat of STI but adds query complexity.",
        category: "ORM",
        difficulty: "advanced",
      },
      {
        question: "What are database indexes in Rails and when should you use them?",
        answer: "Database indexes are data structures that improve the speed of data retrieval operations on database tables. They work similarly to book indexes, allowing the database to find data without scanning the entire table. In Rails, indexes are defined in migration files.\n\n**Creating Indexes**\n\n```ruby\n# Adding an index in a create_table migration\nclass CreateUsers < ActiveRecord::Migration[6.1]\n  def change\n    create_table :users do |t|\n      t.string :email\n      t.string :username\n      t.timestamps\n    end\n    \n    add_index :users, :email, unique: true\n    add_index :users, :username, unique: true\n  end\nend\n\n# Adding an index to an existing table\nclass AddIndexToProducts < ActiveRecord::Migration[6.1]\n  def change\n    add_index :products, :category_id\n    add_index :products, [:name, :manufacturer_id], name: 'idx_products_name_manufacturer'\n  end\nend\n```\n\n**Types of Indexes**\n\n1. **Single-column indexes**: Index on one column\n   ```ruby\n   add_index :products, :category_id\n   ```\n\n2. **Composite indexes**: Index on multiple columns\n   ```ruby\n   add_index :products, [:category_id, :name]\n   ```\n\n3. **Unique indexes**: Enforce uniqueness of values\n   ```ruby\n   add_index :users, :email, unique: true\n   ```\n\n4. **Partial indexes**: Index only a subset of rows\n   ```ruby\n   add_index :orders, :order_number, where: \"status = 'open'\"\n   ```\n\n**When to Use Indexes**\n\n1. **Foreign keys**: Always index foreign key columns\n   ```ruby\n   add_index :comments, :post_id\n   ```\n\n2. **Columns used in WHERE clauses**: Index columns frequently used in query conditions\n   ```ruby\n   add_index :products, :status # If you often query where status = 'active'\n   ```\n\n3. **Columns used in ORDER BY**: Index columns used for sorting\n   ```ruby\n   add_index :posts, :published_at # If you sort by published_at\n   ```\n\n4. **Columns used in JOIN conditions**: Index columns used to join tables\n   ```ruby\n   add_index :order_items, :product_id # If joining orders and products\n   ```\n\n**When NOT to Use Indexes**\n\n1. **Small tables**: Tables with few rows don't benefit much from indexes\n2. **Columns with low cardinality**: Columns with few unique values (e.g., boolean fields)\n3. **Tables with frequent large-batch inserts**: Indexes slow down batch inserts\n4. **Columns rarely used in queries**: Don't index columns that aren't used in queries\n\n**Analyzing Index Usage**\n\nIn PostgreSQL, you can analyze query performance and index usage:\n\n```sql\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';\n```\n\nRails provides database-specific index options like:\n\n```ruby\n# PostgreSQL-specific index types\nadd_index :users, :name, using: :gin\nadd_index :users, \"lower(email)\", name: 'index_users_on_lower_email'\n```\n\nRemember that indexes improve read performance but can slow down writes, so balance them according to your application's read/write patterns.",
        category: "Database",
        difficulty: "intermediate",
      },
      {
        question: "What is Pundit and how do you implement authorization in Rails?",
        answer: "Pundit is a Ruby gem for handling authorization in Rails applications. It uses plain Ruby objects called policies to define authorization rules based on the current user and a specific resource. Pundit follows the principle of object-oriented design and encourages organizing authorization logic into separate policy classes.\n\n**Setup**\n\n```ruby\n# Gemfile\ngem 'pundit'\n\n# app/controllers/application_controller.rb\nclass ApplicationController < ActionController::Base\n  include Pundit::Authorization\n  \n  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized\n  \n  private\n  \n  def user_not_authorized\n    flash[:alert] = \"You are not authorized to perform this action.\"\n    redirect_to(request.referrer || root_path)\n  end\nend\n```\n\n**Creating Policy Classes**\n\n```ruby\n# app/policies/post_policy.rb\nclass PostPolicy < ApplicationPolicy\n  def index?\n    true # Everyone can view the posts index\n  end\n  \n  def show?\n    true # Everyone can view individual posts\n  end\n  \n  def create?\n    user.present? # Only logged in users can create posts\n  end\n  \n  def update?\n    user.present? && (user.admin? || record.user == user)\n    # Only admins or the post author can update it\n  end\n  \n  def destroy?\n    user.present? && (user.admin? || record.user == user)\n    # Only admins or the post author can delete it\n  end\n  \n  # Scope defines which records are visible to a user\n  class Scope < Scope\n    def resolve\n      if user.admin?\n        scope.all # Admins can see all posts\n      else\n        scope.where(published: true).or(scope.where(user: user))\n        # Regular users see published posts and their own drafts\n      end\n    end\n  end\nend\n```\n\n**Using Policies in Controllers**\n\n```ruby\nclass PostsController < ApplicationController\n  before_action :set_post, only: [:show, :edit, :update, :destroy]\n  \n  def index\n    @posts = policy_scope(Post) # Uses the Scope class from the policy\n  end\n  \n  def show\n    authorize @post # Checks if current_user can view this post\n  end\n  \n  def new\n    @post = Post.new\n    authorize @post\n  end\n  \n  def create\n    @post = Post.new(post_params)\n    @post.user = current_user\n    authorize @post\n    \n    if @post.save\n      redirect_to @post, notice: 'Post was created.'\n    else\n      render :new\n    end\n  end\n  \n  def update\n    authorize @post\n    if @post.update(post_params)\n      redirect_to @post, notice: 'Post was updated.'\n    else\n      render :edit\n    end\n  end\n  \n  def destroy\n    authorize @post\n    @post.destroy\n    redirect_to posts_url, notice: 'Post was deleted.'\n  end\n  \n  private\n  \n  def set_post\n    @post = Post.find(params[:id])\n  end\n  \n  def post_params\n    params.require(:post).permit(:title, :content, :published)\n  end\nend\n```\n\n**Using Policies in Views**\n\n```erb\n<% if policy(@post).edit? %>\n  <%= link_to \"Edit\", edit_post_path(@post) %>\n<% end %>\n\n<% if policy(@post).destroy? %>\n  <%= link_to \"Delete\", post_path(@post), method: :delete, data: { confirm: \"Are you sure?\" } %>\n<% end %>\n\n<% if policy(Post).new? %>\n  <%= link_to \"New Post\", new_post_path %>\n<% end %>\n```\n\n**Advanced Features**\n\n1. **Policy Helpers**\n\n```ruby\n# app/policies/application_policy.rb\nclass ApplicationPolicy\n  # Common policy methods\n  def admin_or_owner?\n    user.admin? || record.user_id == user.id\n  end\nend\n```\n\n2. **Headless Policies** (for actions not tied to a model)\n\n```ruby\n# app/policies/dashboard_policy.rb\nclass DashboardPolicy < Struct.new(:user, :dashboard)\n  def show?\n    user.present? # Only authenticated users can see the dashboard\n  end\n  \n  def admin_dashboard?\n    user.admin? # Only admins can see the admin dashboard\n  end\nend\n\n# Controller\nauthorize :dashboard, :admin_dashboard?\n```\n\nPundit provides a clean, object-oriented approach to authorization that scales well as your application grows.",
        category: "Security",
        difficulty: "intermediate",
      },
      {
        question: "What's the difference between render and redirect_to in Rails controllers?",
        answer: "In Rails controllers, `render` and `redirect_to` are two different ways to generate responses, but they work in fundamentally different ways.\n\n**render**\n\nThe `render` method builds a response with a specified template or content without initiating a new request cycle. It stays within the current request.\n\n```ruby\nclass ProductsController < ApplicationController\n  def show\n    @product = Product.find_by(id: params[:id])\n    \n    if @product.nil?\n      # Renders the 'not_found' template with a 404 status\n      render 'not_found', status: :not_found\n    end\n  end\n  \n  def create\n    @product = Product.new(product_params)\n    \n    if @product.save\n      redirect_to @product\n    else\n      # If validation fails, re-render the 'new' template with the form\n      # Variables like @product are still available\n      render 'new'\n    end\n  end\nend\n```\n\nKey characteristics of `render`:\n\n1. **Same request**: Stays within the current request cycle\n2. **Access to variables**: Instance variables set in the action are available in the rendered view\n3. **URL doesn't change**: The browser URL remains the same\n4. **Performance**: Generally faster as it doesn't require a new request\n5. **Form data**: Form data remains populated if rendering after a failed form submission\n\n**redirect_to**\n\nThe `redirect_to` method sends an HTTP redirect (status 302 by default) to the browser, instructing it to make a new request to a different URL. This creates a new request cycle.\n\n```ruby\nclass SessionsController < ApplicationController\n  def create\n    user = User.find_by(email: params[:email])\n    \n    if user&.authenticate(params[:password])\n      session[:user_id] = user.id\n      redirect_to dashboard_path, notice: 'Logged in successfully!'\n    else\n      flash.now[:alert] = 'Invalid email or password'\n      render 'new'\n    end\n  end\n  \n  def destroy\n    session[:user_id] = nil\n    redirect_to root_path, notice: 'Logged out successfully!'\n  end\nend\n```\n\nKey characteristics of `redirect_to`:\n\n1. **New request**: Triggers a completely new request cycle\n2. **No variable access**: Instance variables from the original action are lost\n3. **URL changes**: The browser URL updates to the new location\n4. **Flash messages**: Ideal for setting flash messages that appear after navigation\n5. **Post-redirect-get pattern**: Helps avoid form resubmission issues\n\n**When to use each**\n\nUse `render` when:\n- Displaying a view after form validation errors\n- Showing specialized content based on request parameters\n- Rendering partial content or different formats (JSON, XML)\n- Implementing AJAX responses\n\nUse `redirect_to` when:\n- Following the Post/Redirect/Get pattern after successful form submission\n- Redirecting to a different resource after creating/updating\n- Redirecting after authentication or authorization changes\n- Redirecting to implement a specific user flow\n\n**Performance considerations**:\n\nRedirects require an additional HTTP round-trip, making them slower than rendering. However, they're often necessary for proper application flow and to ensure clean URLs in the browser history.",
        category: "Architecture",
        difficulty: "beginner",
      },
      {
        question: "What are Rails Engines and when would you use them?",
        answer: "Rails Engines are miniature Rails applications that can be mounted inside a larger Rails application. They allow you to encapsulate functionality into reusable, modular components that can be shared across multiple Rails applications.\n\n**Types of Engines**\n\n1. **Full Engines**: Complete applications with their own models, views, controllers, routes, and assets\n2. **Mountable Engines**: Isolated namespace for all components (e.g., `MyEngine::PostsController`)\n3. **Regular Engines**: Share namespace with the parent application\n\n**Creating an Engine**\n\n```bash\n# Generate a mountable engine\n$ rails plugin new blog --mountable\n\n# Generate a full engine\n$ rails plugin new blog --full\n\n# Generate a regular engine\n$ rails plugin new blog\n```\n\nThe generated engine has a structure similar to a Rails application:\n\n```\nblog/\n├── app/\n│   ├── controllers/\n│   │   └── blog/\n│   ├── models/\n│   │   └── blog/\n│   └── views/\n│       └── blog/\n├── config/\n│   └── routes.rb\n├── lib/\n│   ├── blog/\n│   │   └── engine.rb\n│   └── blog.rb\n├── blog.gemspec\n└── Gemfile\n```\n\n**Defining Engine Functionality**\n\n```ruby\n# lib/blog/engine.rb\nmodule Blog\n  class Engine < ::Rails::Engine\n    isolate_namespace Blog\n    \n    initializer \"blog.assets\" do |app|\n      app.config.assets.precompile += %w( blog/blog.css blog/blog.js )\n    end\n    \n    config.generators do |g|\n      g.test_framework :rspec\n    end\n  end\nend\n\n# config/routes.rb (within the engine)\nBlog::Engine.routes.draw do\n  resources :posts\n  root to: 'posts#index'\nend\n```\n\n**Using the Engine in a Host Application**\n\n```ruby\n# Gemfile of the host application\ngem 'blog', path: 'path/to/blog'\n# Or if it's published:\n# gem 'blog', '~> 1.0.0'\n\n# config/routes.rb of the host application\nRails.application.routes.draw do\n  mount Blog::Engine, at: '/blog'\nend\n```\n\n**Sharing Configuration and Data**\n\n```ruby\n# Making models accessible from the host app\n# lib/blog/engine.rb\nmodule Blog\n  class Engine < ::Rails::Engine\n    isolate_namespace Blog\n    \n    # Make engine's models accessible from host app\n    config.to_prepare do\n      # Any necessary inclusions or configurations\n      ApplicationController.helper Blog::ApplicationHelper\n    end\n  end\nend\n```\n\n**When to Use Engines**\n\n1. **Reusing functionality** across multiple Rails applications\n   - Authentication systems\n   - Admin panels\n   - Payment processing\n   - Content management\n\n2. **Organizing large applications** into logical components\n   - Breaking a monolith into smaller pieces\n   - Team separation of concerns\n\n3. **Building commercial components** that can be distributed as gems\n   - SaaS add-ons\n   - Premium features\n\n**Examples of Popular Engine Gems**\n\n- Devise (authentication)\n- Spree (e-commerce)\n- Refinery CMS (content management)\n- ActiveAdmin (admin interface)\n- Thredded (forums)\n\n**Advantages**\n\n- Encapsulation of related functionality\n- Code reuse across applications\n- Clearer boundaries between components\n- Ability to develop and test components in isolation\n\n**Disadvantages**\n\n- Additional complexity\n- Potential for namespace conflicts\n- More challenging to debug\n- Integration testing complexity\n\nEngines are best used when you have truly reusable components that will be shared across multiple applications, or when you want to clearly separate concerns in a large application.",
        category: "Architecture",
        difficulty: "advanced",
      },
      {
        question: "How do you handle file uploads in Rails?",
        answer: "Rails offers several approaches for handling file uploads, from built-in solutions to third-party gems.\n\n**1. Active Storage (Built-in since Rails 5.2)**\n\nActive Storage provides file upload and attachment capabilities with cloud storage service integration.\n\n```ruby\n# Setup\n$ rails active_storage:install\n$ rails db:migrate\n\n# Model configuration\nclass User < ApplicationRecord\n  has_one_attached :avatar\n  has_many_attached :photos\n  \n  # Optional validations\n  validates :avatar, content_type: ['image/png', 'image/jpeg', 'image/jpg']\n  validates :avatar, size: { less_than: 5.megabytes }\nend\n\n# Controller\nclass UsersController < ApplicationController\n  def create\n    @user = User.new(user_params)\n    \n    if @user.save\n      redirect_to @user\n    else\n      render :new\n    end\n  end\n  \n  private\n  \n  def user_params\n    params.require(:user).permit(:name, :email, :avatar, photos: [])\n  end\nend\n\n# View (form)\n<%= form_with model: @user do |form| %>\n  <%= form.label :avatar %>\n  <%= form.file_field :avatar %>\n  \n  <%= form.label :photos %>\n  <%= form.file_field :photos, multiple: true %>\n  \n  <%= form.submit %>\n<% end %>\n\n# View (display)\n<% if @user.avatar.attached? %>\n  <%= image_tag @user.avatar %>\n<% end %>\n\n# Image variants (resizing)\n<%= image_tag @user.avatar.variant(resize_to_limit: [100, 100]) %>\n\n# Direct uploads (browser to cloud)\n<%= form.file_field :avatar, direct_upload: true %>\n```\n\n**2. CarrierWave (Third-party gem)**\n\nCarrierWave offers a flexible solution with many configuration options.\n\n```ruby\n# Gemfile\ngem 'carrierwave'\ngem 'mini_magick' # For image processing\n\n# Generate uploader\n$ rails generate uploader Avatar\n\n# app/uploaders/avatar_uploader.rb\nclass AvatarUploader < CarrierWave::Uploader::Base\n  include CarrierWave::MiniMagick\n  \n  storage :file # or :fog for cloud storage\n  \n  def store_dir\n    \"uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}\"\n  end\n  \n  # Create different versions\n  version :thumb do\n    process resize_to_fit: [100, 100]\n  end\n  \n  # Add validation\n  def extension_allowlist\n    %w(jpg jpeg gif png)\n  end\n  \n  def content_type_allowlist\n    /image\\//\n  end\n  \n  def size_range\n    0..5.megabytes\n  end\nend\n\n# Model\nclass User < ApplicationRecord\n  mount_uploader :avatar, AvatarUploader\n  serialize :photos, JSON # For multiple files\n  mount_uploaders :photos, PhotoUploader\nend\n\n# View (display)\n<%= image_tag @user.avatar.url %>\n<%= image_tag @user.avatar.thumb.url %>\n```\n\n**3. Shrine (Third-party gem)**\n\nShrine is a robust, modular file attachment toolkit with advanced features.\n\n```ruby\n# Gemfile\ngem 'shrine'\ngem 'image_processing'\n\n# config/initializers/shrine.rb\nrequire \"shrine\"\nrequire \"shrine/storage/file_system\"\n\nShrine.storages = {\n  cache: Shrine::Storage::FileSystem.new(\"public\", prefix: \"uploads/cache\"),\n  store: Shrine::Storage::FileSystem.new(\"public\", prefix: \"uploads\")\n}\n\nShrine.plugin :activerecord\nShrine.plugin :cached_attachment_data\nShrine.plugin :restore_cached_data\nShrine.plugin :validation_helpers\nShrine.plugin :determine_mime_type\n\n# app/uploaders/image_uploader.rb\nclass ImageUploader < Shrine\n  Attacher.validate do\n    validate_max_size 5*1024*1024\n    validate_mime_type %w[image/jpeg image/png image/gif]\n  end\n  \n  Attacher.derivatives do |original|\n    magick = ImageProcessing::MiniMagick.source(original)\n    {\n      small: magick.resize_to_limit!(300, 300),\n      medium: magick.resize_to_limit!(500, 500),\n      large: magick.resize_to_limit!(800, 800)\n    }\n  end\nend\n\n# Migration\nclass AddAvatarDataToUsers < ActiveRecord::Migration[6.1]\n  def change\n    add_column :users, :avatar_data, :text\n  end\nend\n\n# Model\nclass User < ApplicationRecord\n  include ImageUploader::Attachment(:avatar)\nend\n\n# Controller\ndef user_params\n  params.require(:user).permit(:name, :avatar)\nend\n\n# View (form)\n<%= form_with model: @user do |form| %>\n  <%= form.hidden_field :avatar, value: @user.avatar_data %>\n  <%= form.file_field :avatar, direct_upload: true %>\n<% end %>\n\n# View (display)\n<% if @user.avatar %>\n  <%= image_tag @user.avatar_url(:small) %>\n<% end %>\n```\n\n**4. Direct Uploads to Cloud Storage**\n\nFor production applications, direct uploads to cloud storage (bypassing your application servers) are recommended for better performance:\n\n```ruby\n# config/storage.yml (Active Storage)\namazon:\n  service: S3\n  access_key_id: <%= ENV['AWS_ACCESS_KEY_ID'] %>\n  secret_access_key: <%= ENV['AWS_SECRET_ACCESS_KEY'] %>\n  region: <%= ENV['AWS_REGION'] %>\n  bucket: <%= ENV['S3_BUCKET_NAME'] %>\n\n# config/environments/production.rb\nconfig.active_storage.service = :amazon\n\n# View (for direct uploads)\n<%= form.file_field :avatar, direct_upload: true %>\n```\n\n**Best Practices**\n\n1. **Always validate uploads**: Check file types, sizes, and dimensions\n2. **Process asynchronously**: Use background jobs for transformations\n3. **Secure file types**: Prevent users from uploading executable files\n4. **Clean up unused files**: Implement a strategy to delete orphaned files\n5. **Consider direct uploads**: For large files or many concurrent uploads\n6. **Use cloud storage in production**: For better scalability and reliability",
        category: "Frontend",
        difficulty: "intermediate",
      },
    ];
    
    questionsData.forEach(question => {
      this.createQuestion(question);
    });
  }
}

export const storage = new MemStorage();